[{"path":"/home/clinux01/Escritorio/eci35_hetprog-main/lab4/add_array_pipes_sycl.cc", "name":"add_array_pipes_sycl.cc", "has_active_debug_locs":false, "absName":"/home/clinux01/Escritorio/eci35_hetprog-main/lab4/add_array_pipes_sycl.cc", "content":"#include <iostream>\u000A#include <random>\u000A#include <vector>\u000A\u000A#include <CL/sycl.hpp>\u000A// Header locations and some DPC++ extensions changed between beta09 and beta10\u000A// Temporarily modify the code sample to accept either version\u000A#define BETA09 20200827\u000A#if __SYCL_COMPILER_VERSION <= BETA09\u000A    #include <sycl/ext/intel/fpga_extensions.hpp>\u000A    namespace INTEL = sycl::intel;  // Namespace alias for backward compatibility\u000A#else\u000A    #include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Ausing namespace sycl;\u000A\u000Aconst size_t pipe_entries = 16; // ensure 512 bit burst\u000Ausing a_pipe = pipe<                 // Defined in the SYCL headers. also ext::intel::pipe\u000A    class a_read_pipe,   // An identifier for the pipe.\u000A    float,                            // The type of data in the pipe.\u000A    pipe_entries>;\u000A\u000Ausing b_pipe = pipe<                 // Defined in the SYCL headers. also ext::intel::pipe\u000A    class b_read_pipe,   // An identifier for the pipe.\u000A    float,                            // The type of data in the pipe.\u000A    pipe_entries>;\u000A\u000Ausing c_pipe = pipe<                 // Defined in the SYCL headers. also ext::intel::pipe\u000A    class c_read_pipe,   // An identifier for the pipe.\u000A    float,                            // The type of data in the pipe.\u000A    pipe_entries>;\u000A\u000A// please complete\u000A\u000Aint main() {\u000A\u000A    const size_t n = 32;\u000A\u000A    std::vector<float> A, B, C(n);\u000A\u000A    A.reserve(n);\u000A    B.reserve(n);\u000A\u000A    std::random_device rd;\u000A    std::mt19937 gen(rd());\u000A    std::uniform_real_distribution<float> dis(0.0f, 1.0f);\u000A\u000A    float value = dis(gen);\u000A    A.push_back(value);\u000A    B.push_back(value - 1.0f);\u000A\u000A    for(size_t i = 1; i < n; ++i) {\u000A    	A.push_back(A[0]+i);\u000A    	B.push_back(B[0]+i);\u000A    }\u000A\u000A#if defined(FPGA_EMULATOR)\u000A    intel::fpga_emulator_selector device_selector;\u000A#else\u000A    intel::fpga_selector device_selector;\u000A#endif\u000A\u000A    // property list to enable SYCL profiling for the device queue\u000A    // auto props = property_list{property::queue::enable_profiling()};\u000A\u000A    // please complete\u000A    queue q;\u000A    \u000A    {\u000A        buffer bufA{A}, bufB{B}, bufC{C};\u000A\u000A        q.submit([&](handler &h){\u000A\u000A            accessor a(bufA, h, read_only);\u000A\u000A            h.single_task<class read_a>([=](){\u000A                for(int i = 0; i < n; i++)\u000A                {\u000A                    a_pipe::write(a[i]);\u000A                }\u000A            });\u000A        });\u000A\u000A        q.submit([&](handler &h){\u000A            \u000A            accessor b(bufB, h, read_only);\u000A\u000A            h.single_task<class read_b>([=](){\u000A                for(int i = 0; i < n; i++)\u000A                {\u000A                    b_pipe::write(b[i]);\u000A                }\u000A            });\u000A        });\u000A\u000A        q.submit([&](handler &h){\u000A            h.single_task<class sum_a_b>([=](){\u000A                for(int i = 0; i < n; i++)\u000A                {\u000A                    auto a_value = a_pipe::read();\u000A                    auto b_value = b_pipe::read();\u000A\u000A                    c_pipe::write(a_value + b_value);\u000A                }\u000A            });\u000A        });\u000A\u000A        q.submit([&](handler &h){\u000A            accessor c(bufC, h, write_only);\u000A\u000A            h.single_task<class write_c>([=](){\u000A                for(int i = 0; i < n; i++)\u000A                {\u000A                    auto res = c_pipe::read();\u000A                    c[i] = res; \u000A                }\u000A            });\u000A        });\u000A\u000A    }\u000A\u000A    for (int i = 0; i < 8; i++) {\u000A      std::cout << \"C[\" << i << \"] = \" << C[i] << std::endl;\u000A    }\u000A}\u000A"}, {"path":"/media/libre/oneapi/tbb/2021.6.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/media/libre/oneapi/tbb/2021.6.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}]